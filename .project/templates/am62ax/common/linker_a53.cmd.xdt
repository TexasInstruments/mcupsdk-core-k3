/*
 *  Copyright (C) 2023 Texas Instruments Incorporated
 *
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions
 *  are met:
 *
 *    Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 *    Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the
 *    distribution.
 *
 *    Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 *  A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 *  OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 *  SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 *  LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 *  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 *  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

%%{
	let options = args.options;

	let stackSize = 0x10000;
	let heapSize =  0x20000;

	let isSingleCore = true;
	let useDdr = true;
	let addrBaseDdr = 0x80000000;
	let codeDataSizeDdr = 0x1000000;

	/* if no options given use defaults */
	if(options && options.stackSize)
		stackSize = options.stackSize;
	if(options && options.heapSize)
		heapSize = options.heapSize;

	if(isSingleCore == true) {
		codeDataAddrDdr = addrBaseDdr;
		codeDataSizeDdr = 0x1000000 * 2;
	}
	else {
		if(args.project.cpu == "a53ss0-0") {
			codeDataAddrDdr = addrBaseDdr + codeDataSizeDdr * 0;
		}
		if(args.project.cpu == "a53ss0-1") {
			codeDataAddrDdr = addrBaseDdr + codeDataSizeDdr * 1;
		}
	}

	if(options && options.addrBaseDdr)
		addrBaseDdr = options.addrBaseDdr;
	if(options && options.codeDataSizeDdr)
		codeDataSizeDdr = options.codeDataSizeDdr;
	if (options && options.enableDMARegion && options.dmaHeapSize) {
		codeDataSizeDdr -= options.dmaHeapSize;
	}
    let globalScratchBuf = "false";
    if(options && options.globalScratchBuf)
    globalScratchBuf = options.globalScratchBuf;
    let ddr2 = "false"
    if(options && options.ddr2)
    ddr2 = options.ddr2;
	%%}

ENTRY(_c_int00)

	__TI_STACK_SIZE = `stackSize`;
	__TI_HEAP_SIZE = `heapSize`;

MEMORY {

	% if(useDdr) {
	DDR : ORIGIN =  0x`(codeDataAddrDdr).toString(16).toUpperCase()`, LENGTH = 0x`(codeDataSizeDdr).toString(16).toUpperCase()`
	% if (options && options.enableDMARegion && options.dmaHeapSize) {
	DDR_DMA : ORIGIN =  0x`(codeDataAddrDdr+codeDataSizeDdr).toString(16).toUpperCase()`, LENGTH = 0x`(options.dmaHeapSize).toString(16).toUpperCase()`
	% }
	% }

	/* shared memory segments */
	/* On A53,
	 * - make sure there is a MMU entry which maps below regions as non-cache
	 */
    USER_SHM_MEM            : ORIGIN = 0x82000000, LENGTH = 0x80
    % if(args.project.isLogSHM === true){
    LOG_SHM_MEM             : ORIGIN = 0xA1000000, LENGTH = 0x40000
    %}
    % if(args.project.ipcVringRTOS === true){
    RTOS_NORTOS_IPC_SHM_MEM : ORIGIN = 0xA0400000, LENGTH = 0x300000
    %}
    % if(globalScratchBuf == "true") {
    /* global scratch buffer region in DDR (32 MB) */
    GLOBAL_SCRATCH_BUFF  (RWIX): ORIGIN = 0x82000080 LENGTH = 0x02000000
    % }
    % if(ddr2 == "true") {
    /* global scratch buffer region in DDR (32 MB) */
    DDR2  (RWIX): ORIGIN = 0x82000080 LENGTH = 0x02000000
    % }
}

SECTIONS {

	.vecs : {} > DDR
		.text : {} > DDR
		.rodata : {} > DDR

		.data : ALIGN (8) {
			__data_load__ = LOADADDR (.data);
			__data_start__ = .;
			*(.data)
				*(.data*)
				. = ALIGN (8);
			__data_end__ = .;
		} > DDR

    /* General purpose user shared memory, used in some examples */
    .bss.user_shared_mem (NOLOAD) : { KEEP(*(.bss.user_shared_mem)) } > USER_SHM_MEM
     % if(args.project.isLogSHM === true){
    /* this is used when Debug log's to shared memory is enabled, else this is not used */
    .bss.log_shared_mem  (NOLOAD) : { KEEP(*(.bss.log_shared_mem)) } > LOG_SHM_MEM
    % }
    % if(args.project.ipcVringRTOS === true) {
    /* this is used only when IPC RPMessage is enabled, else this is not used */
    .bss.ipc_vring_mem   (NOLOAD) : { KEEP(*(.bss.ipc_vring_mem)) } > RTOS_NORTOS_IPC_SHM_MEM
    % }

    % if(globalScratchBuf == "true") {
    /* global scratch buffer region */
    .globalScratchBuffer (NOLOAD) : {} > GLOBAL_SCRATCH_BUFF
    % }
    % if(ddr2 == "true") {
    /* global scratch buffer region */
    DDR2 (NOLOAD) : {} > DDR2
    % }
    .bss : {
        __bss_start__ = .;
        *(.bss)
        *(.bss.*)
        . = ALIGN (8);
        *(COMMON)
        __bss_end__ = .;
        . = ALIGN (8);
    } > DDR

    .heap (NOLOAD) : {
        __heap_start__ = .;
        KEEP(*(.heap))
        . = . + __TI_HEAP_SIZE;
        __heap_end__ = .;
    } > DDR

    .stack (NOLOAD) : ALIGN(16) {
        __TI_STACK_BASE = .;
        KEEP(*(.stack))
        . = . + __TI_STACK_SIZE;
    } > DDR
    % if (options && options.enableDMARegion) {

    .enet_dma_mem (NOLOAD) : {
        *(*ENET_DMA_PKT_MEMPOOL)
     } > DDR_DMA
    % }
}
