%%{
    let common = system.getScript("/common");
    let soc = system.getScript(`/drivers/soc/drivers_${common.getSocName()}`);
    let driverVer = soc.getDriverVer("mcasp");
    let module = system.modules['/drivers/mcasp/mcasp'];
%%}

/*
 * MCASP
 */
% for(let i = 0; i < module.$instances.length; i++) {
    % let instance = module.$instances[i];
    % if(instance.transferMode == "DMA") {
#define MCASP`i`_CYCLIC_BUFF_SIZE_TX    `instance.txCyclicBufSize`U
#define MCASP`i`_CYCLIC_BUFF_COUNT_TX   `instance.txCyclicBufCnt`U
#define MCASP`i`_CYCLIC_BUFF_SIZE_RX    `instance.rxCyclicBufSize`U
#define MCASP`i`_CYCLIC_BUFF_COUNT_RX   `instance.rxCyclicBufCnt`U
    % }
% }


% for(let i = 0; i < module.$instances.length; i++) {
    % let instance = module.$instances[i];
    % let config = module.getInstanceConfig(instance);
    % if(config.enableMcaspTx == true && config.txCallbackFxn != "NULL") {
/* MCASP transmit callback */
void `config.txCallbackFxn`(MCASP_Handle handle, MCASP_Transaction *transaction);
    % }
    % if(config.enableMcaspRx == true && config.rxCallbackFxn != "NULL") {
/* MCASP receive Callback */
void `config.rxCallbackFxn`(MCASP_Handle handle, MCASP_Transaction *transaction);
    % }
    % if(config.enableMcaspTx == true && config.txLoopjobEnable == true) {
/* MCASP transmit loopjob buffer */
uint8_t `config.txLoopjobBuf`[`config.txLoopjobBufLength`] __attribute__((aligned(256))) = {0};
    % }
    % if(config.enableMcaspRx == true && config.rxLoopjobEnable == true) {
/* MCASP receive loopjob buffer */
uint8_t `config.rxLoopjobBuf`[`config.rxLoopjobBufLength`] __attribute__((aligned(256))) = {0};
    % }
% }

/* Arrays containing indices of MCASP Tx/Rx serializers used */
% for(let i = 0; i < module.$instances.length; i++) {
    % let instance = module.$instances[i];
    % let serInstances = instance.mcaspSer;
    % let serTxArr = [], serRxArr = [];
    % let numTxSer = 0, numRxSer = 0;
    % for (let si = 0; si < serInstances.length; si++) {
        % let serInstance = serInstances[si];
        % if(serInstance.dataDir == "Transmit") {
            % serTxArr[numTxSer] = serInstance.serNum;
            % numTxSer++;
        %} else {
            % serRxArr[numRxSer] = serInstance.serNum;
            % numRxSer++;
            % }
    % }
uint8_t gMcasp`i`TxSersUsed[`numTxSer`] = {`serTxArr`};
uint8_t gMcasp`i`RxSersUsed[`numRxSer`] = {`serRxArr`};
% }

% for(let i = 0; i < module.$instances.length; i++) {
    % let instance = module.$instances[i];
    % if(instance.transferMode == "DMA") {
Udma_EventObject gBcdmaTxCqEventObj;
Udma_EventObject gBcdmaRxCqEventObj;

/* Number of ring entries */
#define UDMA_RING_ENTRIES          (1U)
/* Size (in bytes) of each ring entry (Size of pointer - 64-bit) */
#define UDMA_RING_ENTRY_SIZE       (sizeof(uint64_t))

/* Total ring memory */
#define UDMA_RING_MEM_SIZE         (UDMA_RING_ENTRIES * UDMA_RING_ENTRY_SIZE)

/* UDMA TR15 packet descriptor memory size for one TR */
#define UDMA_TR15_TRPD_SIZE         (UDMA_GET_TRPD_TR15_SIZE(1U))
        % break;
    % }
% }

% for(let i = 0; i < module.$instances.length; i++) {
    % let instance = module.$instances[i];
    % if(instance.transferMode == "DMA") {
#define MCASP`i`_TX_TRPD_SIZE (UDMA_GET_TRPD_TR15_SIZE(`instance.txCyclicBufCnt`U))
#define MCASP`i`_RX_TRPD_SIZE (UDMA_GET_TRPD_TR15_SIZE(`instance.rxCyclicBufCnt`U))
    % }
% }

% for(let i = 0; i < module.$instances.length; i++) {
    % let instance = module.$instances[i];
    % if(instance.transferMode == "DMA") {
uint8_t gMcasp`i`_TxCyclicBuff[MCASP`i`_CYCLIC_BUFF_COUNT_TX][MCASP`i`_CYCLIC_BUFF_SIZE_TX] \
                                        __attribute__((aligned(UDMA_CACHELINE_ALIGNMENT)));
uint8_t gMcasp`i`_RxCyclicBuff[MCASP`i`_CYCLIC_BUFF_COUNT_RX][MCASP`i`_CYCLIC_BUFF_SIZE_RX] \
                                        __attribute__((aligned(UDMA_CACHELINE_ALIGNMENT)));

/* TRPDs used for feeding in data to the Cyclic buffer */
uint8_t gMcasp`i`_TrpdMemTx[MCASP`i`_CYCLIC_BUFF_COUNT_TX][UDMA_TR15_TRPD_SIZE];
uint8_t gMcasp`i`_TrpdMemRx[MCASP`i`_CYCLIC_BUFF_COUNT_RX][UDMA_TR15_TRPD_SIZE];

    % }
% }

% for(let i = 0; i < module.$instances.length; i++) {
    % let instance = module.$instances[i];
    % if(instance.transferMode == "DMA") {
MCASP_DmaTrpdMemAlloc gMcasp`i`_TrpdMemAllocTx[MCASP`i`_CYCLIC_BUFF_COUNT_TX + 1] =
{
    % for(let j = 0; j < instance.txCyclicBufCnt; j++) {
    {
        .pTrpdMem = &gMcasp`i`_TrpdMemTx[`j`][0],
        .inUse = 0,
    },
    % }
    {
        .pTrpdMem = (uint8_t *)MCASP_TRPD_INVALID_PTR,
        .inUse = 0,
    },
};

MCASP_DmaTrpdMemAlloc gMcasp`i`_TrpdMemAllocRx[MCASP`i`_CYCLIC_BUFF_COUNT_RX + 1] =
{
    % for(let j = 0; j < instance.rxCyclicBufCnt; j++) {
    {
        .pTrpdMem = &gMcasp`i`_TrpdMemRx[`j`][0],
        .inUse = 0,
    },
    % }
    {
        .pTrpdMem = (uint8_t *)MCASP_TRPD_INVALID_PTR,
        .inUse = 0,
    },
};

    % }
% }

% for(let i = 0; i < module.$instances.length; i++) {
    % let instance = module.$instances[i];
    % let config = module.getInstanceConfig(instance);
    % if(instance.transferMode == "DMA") {
Udma_ChObject       gMcasp`i`UdmaTxChObj;
Udma_EventObject    gMcasp`i`_UdmaCqEventObjTx;

Udma_ChObject       gMcasp`i`UdmaRxChObj;
Udma_EventObject    gMcasp`i`_UdmaCqEventObjRx;

static uint8_t gMcasp`i`UdmaTxTrpdMem[MCASP`i`_TX_TRPD_SIZE] __attribute__((aligned(UDMA_CACHELINE_ALIGNMENT)));
static uint8_t gMcasp`i`UdmaRxTrpdMem[MCASP`i`_RX_TRPD_SIZE] __attribute__((aligned(UDMA_CACHELINE_ALIGNMENT)));

static uint8_t gMcasp`i`TxFqRingMem[UDMA_ALIGN_SIZE(UDMA_RING_MEM_SIZE)] __attribute__((aligned(UDMA_CACHELINE_ALIGNMENT)));
static uint8_t gMcasp`i`RxFqRingMem[UDMA_ALIGN_SIZE(UDMA_RING_MEM_SIZE)] __attribute__((aligned(UDMA_CACHELINE_ALIGNMENT)));

MCASP_DmaChConfig gMcasp`i`_DmaChCfg[] =
{
    {
        .txChHandle         = &gMcasp`i`UdmaTxChObj,
        .rxChHandle         = &gMcasp`i`UdmaRxChObj,
        .cqTxEvtHandle      = &gMcasp`i`_UdmaCqEventObjTx,
        .cqRxEvtHandle      = &gMcasp`i`_UdmaCqEventObjRx,
        .txTrpdMem          = gMcasp`i`UdmaTxTrpdMem,
        .rxTrpdMem          = gMcasp`i`UdmaRxTrpdMem,
        .txRingMem          = gMcasp`i`TxFqRingMem,
        .rxRingMem          = gMcasp`i`RxFqRingMem,
        .ringMemSize        = UDMA_RING_MEM_SIZE,
        .ringElemCnt        = UDMA_RING_ENTRIES,
        .rxEvtNum           = `config.udmaPdmaChannels[0].rxCh`,
        .txEvtNum           = `config.udmaPdmaChannels[0].txCh`,
    }
};
    % }
% }

/* MCASP Driver handles */
MCASP_Handle gMcaspHandle[CONFIG_MCASP_NUM_INSTANCES];
/* MCASP Driver Open Parameters */
MCASP_OpenParams gMcaspOpenParams[CONFIG_MCASP_NUM_INSTANCES] =
{
% for(let i = 0; i < module.$instances.length; i++) {
    % let instance = module.$instances[i];
    % let config = module.getInstanceConfig(instance);
    {
        .transferMode = MCASP_TRANSFER_MODE_`instance.transferMode`,
        .txBufferFormat = MCASP_AUDBUFF_FORMAT_`instance.txBufferFormat`,
        .rxBufferFormat = MCASP_AUDBUFF_FORMAT_`instance.rxBufferFormat`,
        % let serInstances = instance.mcaspSer;
        % let serTxArr = [], serRxArr = [];
        % let numTxSer = 0, numRxSer = 0;
        % for (let si = 0; si < serInstances.length; si++) {
            % let serInstance = serInstances[si];
            % if(serInstance.dataDir == "Transmit") {
                % serTxArr[numTxSer] = serInstance.serNum;
                % numTxSer++;
            %} else {
                % serRxArr[numRxSer] = serInstance.serNum;
                % numRxSer++;
            % }
        % }
        .txSerUsedCount = `numTxSer`,
        .rxSerUsedCount = `numRxSer`,
        .txSerUsedArray = (uint8_t *) gMcasp`i`TxSersUsed,
        .rxSerUsedArray = (uint8_t *) gMcasp`i`RxSersUsed,
        .txSlotCount = `instance.NumTxSlots`,
        .rxSlotCount = `instance.NumRxSlots`,
        % if(config.enableMcaspTx == true && config.txCallbackFxn != "NULL") {
        .txCallbackFxn = `instance.txCallbackFxn`,
        % }
         % if(config.enableMcaspRx == true && config.rxCallbackFxn != "NULL") {
        .rxCallbackFxn = `instance.rxCallbackFxn`,
        % }
        .txLoopjobEnable = `config.txLoopjobEnable`,
        % if(config.enableMcaspTx == true && config.txLoopjobEnable == true) {
        .txLoopjobBuf = (uint8_t *) `instance.txLoopjobBuf`,
        .txLoopjobBufLength = `instance.txLoopjobBufLength / (instance.TxSlotSize / 8)`,
        .rxLoopjobEnable = `config.rxLoopjobEnable`,
        % }
        % if(config.enableMcaspRx == true && config.rxLoopjobEnable == true) {
        .rxLoopjobBuf = (uint8_t *) `instance.rxLoopjobBuf`,
        .rxLoopjobBufLength = `instance.rxLoopjobBufLength / (instance.RxSlotSize / 8)`,
        % }
        % if(config.transferMode == "DMA") {
        .bcdmaTxCqEvtHandle = &gBcdmaTxCqEventObj,
        .bcdmaRxCqEvtHandle = &gBcdmaRxCqEventObj,
        .bcdmaDrvHandle = &gUdmaDrvObj[0],

        .cyclicBuffTx = (uint8_t *)gMcasp`i`_TxCyclicBuff,
        .cyclicBuffRx = (uint8_t *)gMcasp`i`_RxCyclicBuff,

        .cyclicBuffSizeTx = MCASP`i`_CYCLIC_BUFF_SIZE_TX,
        .cyclicBuffCntTx = MCASP`i`_CYCLIC_BUFF_COUNT_TX,

        .cyclicBuffSizeRx = MCASP`i`_CYCLIC_BUFF_SIZE_RX,
        .cyclicBuffCntRx = MCASP`i`_CYCLIC_BUFF_COUNT_RX,

        .cyclicTxFeedDMAHandle = &gConfigUdma0BlkCopyChHandle[0],
        .cyclicRxFeedDMAHandle = &gConfigUdma0BlkCopyChHandle[1],

        .trpdMemAllocTx = gMcasp`i`_TrpdMemAllocTx,
        .trpdMemAllocRx = gMcasp`i`_TrpdMemAllocRx,

        .dmaChCfg = &gMcasp`i`_DmaChCfg[0],
        .mcaspDmaDrvObj = &gUdmaDrvObj[0],
        % }
    },
    %}
};


void Drivers_mcaspOpen(void)
{
    uint32_t instCnt;
    int32_t  status = SystemP_SUCCESS;

    for(instCnt = 0U; instCnt < CONFIG_MCASP_NUM_INSTANCES; instCnt++)
    {
        gMcaspHandle[instCnt] = NULL;   /* Init to NULL so that we can exit gracefully */
    }

    /* Open all instances */
    for(instCnt = 0U; instCnt < CONFIG_MCASP_NUM_INSTANCES; instCnt++)
    {
        gMcaspHandle[instCnt] = MCASP_open(instCnt, &gMcaspOpenParams[instCnt]);
        if(NULL == gMcaspHandle[instCnt])
        {
            DebugP_logError("MCASP open failed for instance %d !!!\r\n", instCnt);
            status = SystemP_FAILURE;
            break;
        }
    }

    if(SystemP_FAILURE == status)
    {
        Drivers_mcaspClose();   /* Exit gracefully */
    }

    return;
}

void Drivers_mcaspClose(void)
{
    uint32_t instCnt;
    int32_t status;

    /* Close all instances that are open */
    for(instCnt = 0U; instCnt < CONFIG_MCASP_NUM_INSTANCES; instCnt++)
    {
        if(gMcaspHandle[instCnt] != NULL)
        {
            MCASP_close(gMcaspHandle[instCnt]);
        }
    }

    /* BCDMA for feeding in and out the cyclic buffer is shared across instances.\
       So deregister the event once */
    for(instCnt = 0U; instCnt < CONFIG_MCASP_NUM_INSTANCES; instCnt++)
    {
        if(gMcaspHandle[instCnt] != NULL)
        {
            MCASP_Object *obj = ((MCASP_Config *)gMcaspHandle[instCnt])->object;

            status = Udma_eventUnRegister(obj->bcdmaTxCyclicEvtHandle);
            DebugP_assert(SystemP_SUCCESS == status);

            status = Udma_eventUnRegister(obj->bcdmaRxCyclicEvtHandle);
            DebugP_assert(SystemP_SUCCESS == status);

            break;
        }
    }

    for(instCnt = 0U; instCnt < CONFIG_MCASP_NUM_INSTANCES; instCnt++)
    {
        if(gMcaspHandle[instCnt] != NULL)
        {
            gMcaspHandle[instCnt] = NULL;
        }
    }

    return;
}
